#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Nov 21 10:52:38 2016

@author: emmanuel
"""


# coding: utf-8

from style import make
import matplotlib.pyplot as plt
import scipy as sp
import pyabc
import pandas as pd
import parallel
plt.rcParams['image.cmap'] = 'viridis'

sm = make(output="testdb.db")

cov = sp.array([[.5, 0],
                [0, .5]])

data = sp.array([1, 1])
data


def p(x, theta):
    return 1 / sp.pi * sp.exp(-((x-theta**2)**2).sum(axis=-1))


MAX_SIZE = 10


TX, TY = sp.meshgrid(sp.linspace(-MAX_SIZE, MAX_SIZE, 200),
                     sp.linspace(-MAX_SIZE, MAX_SIZE, 200))


TXY = sp.stack((TX, TY), axis=2)


density = p(TXY, sp.array([0, 0]))


plt.pcolor(TX, TY, density);
plt.gca().set_aspect("equal")


def prior(theta):
    return 1/20**2 * ((-MAX_SIZE < theta) & (theta < MAX_SIZE)).all(axis=-1).astype(float)



def posterior(theta, data):
    return p(data, theta) * prior(theta)


plt.pcolor(TX, TY, posterior(TXY, data));
plt.gca().set_aspect("equal")
plt.colorbar()
plt.show()


def abc_model(args):
    theta_squared = sp.array([args.theta1, args.theta2])**2
    sample = sp.random.multivariate_normal(theta_squared, cov)
    return {"x": sample[0], "y": sample[1]}


class ABCPrior:
    def pdf(self, x):
        return prior(sp.array([x.theta1, x.theta2]))
    
    def rvs(self):
        sample = sp.rand(2) * 2 * MAX_SIZE - MAX_SIZE
        return pyabc.Parameter({"theta1": sample[0], "theta2": sample[1]})



model_prior = pyabc.RV("randint", 0, 1)
population_size = pyabc.populationstrategy.AdaptivePopulationStrategy(500, 20,
                                                                      max_population_size=10000)



mapper = parallel.SGE().map if parallel.sge_available() else map
abc = pyabc.ABCSMC([pyabc.SimpleModel(abc_model)],
                    model_prior,
                    pyabc.ModelPerturbationKernel(1, probability_to_stay=.8),
                    [ABCPrior()],
                    [pyabc.MultivariateNormalTransition()],
                    pyabc.PercentileDistanceFunction(measures_to_use=["x", "y"]),
                    pyabc.MedianEpsilon(),
                    population_size,
                    sampler=parallel.sampler.MappingSampler(map=mapper))
abc.stop_if_only_single_model_alive = False




options = {'db_path': "sqlite:///" + sm.output[0]}
abc.set_data({"x": 1, "y": 1}, 0, {}, options)




history = abc.run(.01)




t = 9
points_theta1, weights_theta_1 =  history.get_distribution(t, 0, "theta1")
points_theta2, weights_theta_2 = history.get_distribution(t, 0, "theta2")
hist, xedges, yedges = sp.histogram2d(points_theta1, points_theta2,
                                      weights=weights_theta_1, bins=30);
xedges_mesh, yedges_mesh = sp.meshgrid(xedges[:-1], yedges[:-1])
plt.pcolor(xedges_mesh, yedges_mesh, hist)



ds = pd.Series(TXY[0][0], index=["theta1", "theta2"])



kde = [[abc.transitions[0].pdf(pd.Series(theta, index=["theta1", "theta2"]))
       for theta in pairs] for pairs in TXY]



plt.pcolor(TX, TY, sp.array(kde));
plt.gca().set_aspect("equal")



for t in range(1, history.t + 1):
    abc.fit_transitions(t)
    kdef = sp.array([[abc.transitions[0].pdf(pd.Series(theta, index=["theta1", "theta2"]))
           for theta in pairs] for pairs in TXY])
    plt.pcolor(TX, TY, kdef);
    plt.gca().set_aspect("equal")
    plt.title("t={}".format(t))
    plt.savefig("/u/eklinger/tmp/pop_{}.png".format(t))
    plt.show()
